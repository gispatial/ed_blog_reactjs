{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryService = exports.RetryService = void 0;\n\nvar headers_helper_1 = require(\"./headers-helper\");\n\nvar RetryService =\n/** @class */\nfunction () {\n  function RetryService() {\n    var _this = this;\n\n    this.retryAfterHeaderName = 'Retry-After';\n    this.useRetryForStatusCodes = [408, 429, 500, 502, 503, 504];\n    this.defaultRetryPolicy = {\n      addJitter: true,\n      deltaBackoffMs: 1000,\n      maxCumulativeWaitTimeMs: 30000,\n      maxAttempts: 20,\n      canRetryError: function (error) {\n        return _this.canRetryErrorDefault(error);\n      }\n    };\n  }\n\n  RetryService.prototype.getRetryStrategyFromStrategyOptions = function (retryOptions) {\n    if (!retryOptions) {\n      return this.defaultRetryPolicy;\n    }\n\n    return retryOptions;\n  };\n\n  RetryService.prototype.canRetryInTime = function (startTime, maxCumulativeWaitTimeMs) {\n    var start = startTime.getTime();\n    var now = new Date().getTime();\n    var differenceInMs = now - start;\n    return {\n      canRetry: differenceInMs < maxCumulativeWaitTimeMs,\n      differenceInMs: differenceInMs\n    };\n  };\n  /**\r\n   * Logs attempt in console.\r\n   * This function is also used for testing in jasmine spy\r\n   */\n\n\n  RetryService.prototype.debugLogAttempt = function (attempt, waitTime) {\n    console.warn(\"Attempt \" + attempt + \": retrying in \" + waitTime + \"ms\");\n  };\n\n  RetryService.prototype.getNextWaitTimeMs = function (addJitter, deltaBackoffMs, retryAttempts, retryAfterInMs) {\n    if (retryAfterInMs) {\n      return retryAfterInMs;\n    }\n\n    if (!addJitter) {\n      return deltaBackoffMs * Math.pow(2, retryAttempts);\n    }\n\n    var from = 0.8 * deltaBackoffMs;\n    var to = 1.2 * deltaBackoffMs * Math.pow(2, retryAttempts);\n    return this.randomNumberFromInterval(from, to);\n  };\n\n  RetryService.prototype.canRetryErrorDefault = function (error) {\n    var axiosError = this.tryGetAxiosError(error);\n\n    if (!axiosError) {\n      // by default non-axios errors are not retried\n      return false;\n    }\n\n    var statusCode = this.getStatusCodeFromError(error);\n    var canRetryStatusCode = this.canRetryStatusCode(statusCode, this.useRetryForStatusCodes);\n\n    if (canRetryStatusCode) {\n      return true;\n    }\n\n    return false;\n  };\n\n  RetryService.prototype.canRetryStatusCode = function (statusCode, useRetryForResponseCodes) {\n    return useRetryForResponseCodes.includes(statusCode);\n  };\n\n  RetryService.prototype.isAxiosError = function (error) {\n    var _a, _b;\n\n    return (_b = (_a = this.tryGetAxiosError(error)) === null || _a === void 0 ? void 0 : _a.isAxiosError) !== null && _b !== void 0 ? _b : false;\n  };\n\n  RetryService.prototype.getStatusCodeFromError = function (error) {\n    var axiosError = this.tryGetAxiosError(error);\n\n    if (!axiosError || !axiosError.response) {\n      return 0;\n    }\n\n    return axiosError.response.status;\n  };\n\n  RetryService.prototype.tryGetRetryAfterInMsFromError = function (error) {\n    var _this = this;\n\n    var axiosError = this.tryGetAxiosError(error);\n\n    if (!axiosError || !axiosError.response) {\n      return undefined;\n    }\n\n    var headers = headers_helper_1.extractHeadersFromAxiosResponse(axiosError.response);\n    var retryValueHeader = headers.find(function (m) {\n      return m.header.toLowerCase() === _this.retryAfterHeaderName.toLowerCase();\n    });\n\n    if (!retryValueHeader) {\n      return undefined;\n    }\n\n    var retryValue = retryValueHeader.value;\n\n    if (isNaN(+retryValue)) {\n      // header is date\n      var retryAfter = new Date(retryValue).getTime();\n      var now = new Date().getTime();\n      var differenceInMs = retryAfter - now;\n      return differenceInMs;\n    } else {\n      // header is number\n      var retryValueInMs = +retryValue * 1000;\n      return retryValueInMs;\n    }\n  };\n\n  RetryService.prototype.tryGetAxiosError = function (error) {\n    if (!error) {\n      return undefined;\n    }\n\n    if (error.isAxiosError) {\n      return error;\n    }\n\n    var originalError = error.originalError;\n\n    if (originalError && originalError.isAxiosError) {\n      return originalError;\n    }\n\n    return undefined;\n  };\n  /**\r\n   * min and max included\r\n   */\n\n\n  RetryService.prototype.randomNumberFromInterval = function (min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  };\n\n  return RetryService;\n}();\n\nexports.RetryService = RetryService;\nexports.retryService = new RetryService();","map":{"version":3,"sources":["../../lib/http/retry-service.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.retryService = exports.RetryService = void 0;\r\nvar headers_helper_1 = require(\"./headers-helper\");\r\nvar RetryService = /** @class */ (function () {\r\n    function RetryService() {\r\n        var _this = this;\r\n        this.retryAfterHeaderName = 'Retry-After';\r\n        this.useRetryForStatusCodes = [408, 429, 500, 502, 503, 504];\r\n        this.defaultRetryPolicy = {\r\n            addJitter: true,\r\n            deltaBackoffMs: 1000,\r\n            maxCumulativeWaitTimeMs: 30000,\r\n            maxAttempts: 20,\r\n            canRetryError: function (error) { return _this.canRetryErrorDefault(error); }\r\n        };\r\n    }\r\n    RetryService.prototype.getRetryStrategyFromStrategyOptions = function (retryOptions) {\r\n        if (!retryOptions) {\r\n            return this.defaultRetryPolicy;\r\n        }\r\n        return retryOptions;\r\n    };\r\n    RetryService.prototype.canRetryInTime = function (startTime, maxCumulativeWaitTimeMs) {\r\n        var start = startTime.getTime();\r\n        var now = new Date().getTime();\r\n        var differenceInMs = now - start;\r\n        return {\r\n            canRetry: differenceInMs < maxCumulativeWaitTimeMs,\r\n            differenceInMs: differenceInMs\r\n        };\r\n    };\r\n    /**\r\n     * Logs attempt in console.\r\n     * This function is also used for testing in jasmine spy\r\n     */\r\n    RetryService.prototype.debugLogAttempt = function (attempt, waitTime) {\r\n        console.warn(\"Attempt \" + attempt + \": retrying in \" + waitTime + \"ms\");\r\n    };\r\n    RetryService.prototype.getNextWaitTimeMs = function (addJitter, deltaBackoffMs, retryAttempts, retryAfterInMs) {\r\n        if (retryAfterInMs) {\r\n            return retryAfterInMs;\r\n        }\r\n        if (!addJitter) {\r\n            return deltaBackoffMs * Math.pow(2, retryAttempts);\r\n        }\r\n        var from = 0.8 * deltaBackoffMs;\r\n        var to = 1.2 * deltaBackoffMs * Math.pow(2, retryAttempts);\r\n        return this.randomNumberFromInterval(from, to);\r\n    };\r\n    RetryService.prototype.canRetryErrorDefault = function (error) {\r\n        var axiosError = this.tryGetAxiosError(error);\r\n        if (!axiosError) {\r\n            // by default non-axios errors are not retried\r\n            return false;\r\n        }\r\n        var statusCode = this.getStatusCodeFromError(error);\r\n        var canRetryStatusCode = this.canRetryStatusCode(statusCode, this.useRetryForStatusCodes);\r\n        if (canRetryStatusCode) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    RetryService.prototype.canRetryStatusCode = function (statusCode, useRetryForResponseCodes) {\r\n        return useRetryForResponseCodes.includes(statusCode);\r\n    };\r\n    RetryService.prototype.isAxiosError = function (error) {\r\n        var _a, _b;\r\n        return (_b = (_a = this.tryGetAxiosError(error)) === null || _a === void 0 ? void 0 : _a.isAxiosError) !== null && _b !== void 0 ? _b : false;\r\n    };\r\n    RetryService.prototype.getStatusCodeFromError = function (error) {\r\n        var axiosError = this.tryGetAxiosError(error);\r\n        if (!axiosError || !axiosError.response) {\r\n            return 0;\r\n        }\r\n        return axiosError.response.status;\r\n    };\r\n    RetryService.prototype.tryGetRetryAfterInMsFromError = function (error) {\r\n        var _this = this;\r\n        var axiosError = this.tryGetAxiosError(error);\r\n        if (!axiosError || !axiosError.response) {\r\n            return undefined;\r\n        }\r\n        var headers = headers_helper_1.extractHeadersFromAxiosResponse(axiosError.response);\r\n        var retryValueHeader = headers.find(function (m) { return m.header.toLowerCase() === _this.retryAfterHeaderName.toLowerCase(); });\r\n        if (!retryValueHeader) {\r\n            return undefined;\r\n        }\r\n        var retryValue = retryValueHeader.value;\r\n        if (isNaN(+retryValue)) {\r\n            // header is date\r\n            var retryAfter = new Date(retryValue).getTime();\r\n            var now = new Date().getTime();\r\n            var differenceInMs = retryAfter - now;\r\n            return differenceInMs;\r\n        }\r\n        else {\r\n            // header is number\r\n            var retryValueInMs = +retryValue * 1000;\r\n            return retryValueInMs;\r\n        }\r\n    };\r\n    RetryService.prototype.tryGetAxiosError = function (error) {\r\n        if (!error) {\r\n            return undefined;\r\n        }\r\n        if (error.isAxiosError) {\r\n            return error;\r\n        }\r\n        var originalError = error.originalError;\r\n        if (originalError && originalError.isAxiosError) {\r\n            return originalError;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * min and max included\r\n     */\r\n    RetryService.prototype.randomNumberFromInterval = function (min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1) + min);\r\n    };\r\n    return RetryService;\r\n}());\r\nexports.RetryService = RetryService;\r\nexports.retryService = new RetryService();\r\n//# sourceMappingURL=retry-service.js.map"]},"metadata":{},"sourceType":"script"}