{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElementMapper = void 0;\n\nvar kontent_core_1 = require(\"@kentico/kontent-core\");\n\nvar config_1 = require(\"../config\");\n\nvar elements_1 = require(\"../elements\");\n\nvar models_1 = require(\"../models\");\n\nvar resolvers_1 = require(\"../resolvers\");\n\nvar ElementMapper =\n/** @class */\nfunction () {\n  function ElementMapper(config, richTextHtmlParser) {\n    this.config = config;\n    this.richTextHtmlParser = richTextHtmlParser;\n    this.defaultLinkedItemWrapperTag = 'p';\n    this.defaultLinkedItemWrapperClasses = ['kc-linked-item-wrapper'];\n  }\n  /**\r\n   * Maps all element in given content item and returns strongly typed content item based on the resolver specified\r\n   * in DeliveryClientConfig\r\n   */\n\n\n  ElementMapper.prototype.mapElements = function (data) {\n    var _this = this; // return processed item if possible (to avoid infinite recursion)\n\n\n    var processedItem = data.processedItems[data.item.system.codename];\n\n    if (processedItem) {\n      // item was already resolved, return it\n      return {\n        item: processedItem,\n        processedItems: data.processedItems,\n        preparedItems: data.preparedItems,\n        processingStartedForCodenames: data.processingStartedForCodenames\n      };\n    }\n\n    var elementCodenames = Object.getOwnPropertyNames(data.item.elements);\n    var itemInstance = data.preparedItems[data.item.system.codename];\n\n    if (!itemInstance) {\n      // item is not present in response, no need to do any mapping\n      return undefined;\n    }\n\n    elementCodenames.forEach(function (elementCodename) {\n      var elementMap = _this.resolveElementMap(itemInstance, elementCodename);\n\n      var elementWrapper = {\n        contentItemSystem: data.item.system,\n        rawElement: data.item.elements[elementCodename],\n        propertyName: elementMap.resolvedName\n      };\n\n      if (elementMap.shouldMapElement) {\n        var mappedElement = _this.mapElement({\n          elementWrapper: elementWrapper,\n          item: itemInstance,\n          preparedItems: data.preparedItems,\n          processingStartedForCodenames: data.processingStartedForCodenames,\n          processedItems: data.processedItems,\n          queryConfig: data.queryConfig\n        }); // set mapped element to item instance\n\n\n        itemInstance[elementMap.resolvedName] = mappedElement;\n      }\n    });\n    return {\n      item: itemInstance,\n      processedItems: data.processedItems,\n      preparedItems: data.preparedItems,\n      processingStartedForCodenames: data.processingStartedForCodenames\n    };\n  };\n\n  ElementMapper.prototype.mapElement = function (data) {\n    var elementType = kontent_core_1.enumHelper.getEnumFromValue(elements_1.ElementType, data.elementWrapper.rawElement.type);\n\n    if (elementType) {\n      if (elementType === elements_1.ElementType.ModularContent) {\n        return this.mapLinkedItemsElement({\n          elementWrapper: data.elementWrapper,\n          preparedItems: data.preparedItems,\n          processingStartedForCodenames: data.processingStartedForCodenames,\n          processedItems: data.processedItems,\n          queryConfig: data.queryConfig\n        });\n      }\n\n      if (elementType === elements_1.ElementType.Text) {\n        return this.mapTextElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.Asset) {\n        return this.mapAssetsElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.Number) {\n        return this.mapNumberElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.MultipleChoice) {\n        return this.mapMultipleChoiceElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.DateTime) {\n        return this.mapDateTimeElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.RichText) {\n        return this.mapRichTextElement(data.item, data.elementWrapper, data.queryConfig, data.processedItems, data.processingStartedForCodenames, data.preparedItems);\n      }\n\n      if (elementType === elements_1.ElementType.UrlSlug) {\n        return this.mapUrlSlugElement(data.elementWrapper, data.item, data.queryConfig);\n      }\n\n      if (elementType === elements_1.ElementType.Taxonomy) {\n        return this.mapTaxonomyElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.Custom) {\n        return this.mapCustomElement(data.elementWrapper);\n      }\n    }\n\n    console.warn(\"Could not map element '\" + data.elementWrapper.rawElement.name + \"' of type '\" + data.elementWrapper.rawElement.type + \"'. Returning unknown element instead.\");\n    return this.mapUnknowElement(data.elementWrapper);\n  };\n\n  ElementMapper.prototype.mapRichTextElement = function (item, elementWrapper, queryConfig, processedItems, processingStartedForCodenames, preparedItems) {\n    var _this = this; // get all linked items nested in rich text\n\n\n    var richTextLinkedItems = [];\n    var rawElement = elementWrapper.rawElement;\n\n    if (rawElement.modular_content) {\n      if (Array.isArray(rawElement.modular_content)) {\n        rawElement.modular_content.forEach(function (codename) {\n          // get linked item and check if it exists (it might not be included in response due to 'Depth' parameter)\n          var preparedItem = preparedItems[codename]; // first try to get existing item\n\n          var existingLinkedItem = _this.getOrSaveLinkedItemForElement(codename, rawElement, queryConfig, processedItems, processingStartedForCodenames, preparedItems);\n\n          if (existingLinkedItem) {\n            // item was found, add it to linked items\n            richTextLinkedItems.push(existingLinkedItem);\n          } else {\n            var throwErrorForMissingLinkedItems = false; // check if errors should be thrown for missing linked items\n\n            if (queryConfig.throwErrorForMissingLinkedItems === false || queryConfig.throwErrorForMissingLinkedItems === true) {\n              // variable is a boolean\n              throwErrorForMissingLinkedItems = queryConfig.throwErrorForMissingLinkedItems;\n            } // throw error if raw item is not available and errors are not skipped\n\n\n            if (!preparedItem) {\n              var msg = \"Mapping RichTextElement element '\" + rawElement.name + \"' failed because referenced linked item with codename '\" + codename + \"' could not be found in Delivery response.\\n                            Increasing 'depth' parameter may solve this issue as it will include nested items. Alternatively you may disable 'throwErrorForMissingLinkedItems' in your query\";\n\n              if (throwErrorForMissingLinkedItems) {\n                throw Error(msg);\n              }\n            } // item was not found or not yet resolved\n\n\n            if (preparedItem) {\n              var mappedLinkedItemResult = _this.mapElements({\n                item: preparedItem._raw,\n                preparedItems: preparedItems,\n                processingStartedForCodenames: processingStartedForCodenames,\n                processedItems: processedItems,\n                queryConfig: queryConfig\n              }); // add mapped linked item to result\n\n\n              if (mappedLinkedItemResult) {\n                richTextLinkedItems.push(mappedLinkedItemResult.item);\n              }\n            }\n          }\n        });\n      }\n    } // extract and map links & images\n\n\n    var links = this.mapRichTextLinks(rawElement.links);\n    var images = this.mapRichTextImages(rawElement.images);\n    return new elements_1.Elements.RichTextElement(elementWrapper, rawElement.modular_content, {\n      links: links,\n      resolveRichTextFunc: function () {\n        return resolvers_1.richTextResolver.resolveData(item.system.codename, rawElement.value, elementWrapper.propertyName, {\n          enableAdvancedLogging: _this.config.isDeveloperMode ? _this.config.isDeveloperMode : false,\n          getGlobalUrlSlugResolver: function (type) {\n            return _this.getGlobalUrlSlugResolverForType(type);\n          },\n          images: images,\n          richTextHtmlParser: _this.richTextHtmlParser,\n          getLinkedItem: function (codename) {\n            return _this.getOrSaveLinkedItemForElement(codename, rawElement, queryConfig, processedItems, processingStartedForCodenames, preparedItems);\n          },\n          links: links,\n          queryConfig: queryConfig,\n          linkedItemWrapperTag: _this.config.linkedItemResolver && _this.config.linkedItemResolver.linkedItemWrapperTag ? _this.config.linkedItemResolver.linkedItemWrapperTag : _this.defaultLinkedItemWrapperTag,\n          linkedItemWrapperClasses: _this.config.linkedItemResolver && _this.config.linkedItemResolver.linkedItemWrapperClasses ? _this.config.linkedItemResolver.linkedItemWrapperClasses : _this.defaultLinkedItemWrapperClasses\n        });\n      },\n      images: images\n    });\n  };\n\n  ElementMapper.prototype.mapDateTimeElement = function (elementWrapper) {\n    return new elements_1.Elements.DateTimeElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapMultipleChoiceElement = function (elementWrapper) {\n    return new elements_1.Elements.MultipleChoiceElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapNumberElement = function (elementWrapper) {\n    return new elements_1.Elements.NumberElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapTextElement = function (elementWrapper) {\n    return new elements_1.Elements.TextElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapAssetsElement = function (elementWrapper) {\n    return new elements_1.Elements.AssetsElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapTaxonomyElement = function (elementWrapper) {\n    return new elements_1.Elements.TaxonomyElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapUnknowElement = function (elementWrapper) {\n    return new elements_1.Elements.UnknownElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapCustomElement = function (elementWrapper) {\n    // try to find element resolver\n    if (this.config.elementResolver) {\n      var customElementClass = this.config.elementResolver(elementWrapper);\n\n      if (customElementClass) {\n        return customElementClass;\n      }\n    }\n\n    return new elements_1.Elements.DefaultCustomElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapUrlSlugElement = function (elementWrapper, item, queryConfig) {\n    var _this = this;\n\n    var resolver = this.getUrlSlugResolverForElement(item, elementWrapper, queryConfig);\n    return new elements_1.Elements.UrlSlugElement(elementWrapper, {\n      resolveLinkFunc: function () {\n        return resolvers_1.urlSlugResolver.resolveUrl({\n          elementName: elementWrapper.propertyName,\n          elementValue: elementWrapper.rawElement.value,\n          item: item,\n          enableAdvancedLogging: _this.config.isDeveloperMode ? _this.config.isDeveloperMode : false,\n          resolver: resolver\n        }).url || '';\n      }\n    });\n  };\n\n  ElementMapper.prototype.mapLinkedItemsElement = function (data) {\n    var _this = this; // prepare linked items\n\n\n    var linkedItems = []; // value = array of item codenames\n\n    var linkedItemCodenames = data.elementWrapper.rawElement.value;\n    linkedItemCodenames.forEach(function (codename) {\n      var linkedItem = _this.getOrSaveLinkedItemForElement(codename, data.elementWrapper.rawElement, data.queryConfig, data.processedItems, data.processingStartedForCodenames, data.preparedItems);\n\n      if (linkedItem) {\n        // add item to result\n        linkedItems.push(linkedItem);\n      } else {\n        // item was not found\n        if (_this.config.isDeveloperMode) {\n          // tslint:disable-next-line:max-line-length\n          console.warn(\"Linked item with codename '\" + codename + \"' in linked items element '\" + data.elementWrapper.rawElement.name + \"' of '\" + data.elementWrapper.rawElement.type + \"' type could not be found. If you require this item, consider increasing 'depth' of your query. This warning can be turned off by disabling 'enableAdvancedLogging' option.\");\n        }\n      }\n    });\n    return new elements_1.Elements.LinkedItemsElement(data.elementWrapper, linkedItems);\n  };\n\n  ElementMapper.prototype.getUrlSlugResolverForElement = function (item, elementWrapper, queryConfig) {\n    // query `urlSlugResolver` has priority over global resolver\n    if (queryConfig.urlSlugResolver) {\n      return queryConfig.urlSlugResolver;\n    }\n\n    if (item._config && item._config.urlSlugResolver) {\n      return item._config.urlSlugResolver;\n    } // resolve default link value\n\n\n    return function () {\n      return elementWrapper.rawElement.value;\n    };\n  };\n\n  ElementMapper.prototype.getOrSaveLinkedItemForElement = function (codename, element, queryConfig, processedItems, mappingStartedForCodenames, preparedItems) {\n    // first check if item was already resolved and return it if it was\n    var processedItem = processedItems[codename];\n\n    if (processedItem) {\n      // item was already resolved\n      return processedItem;\n    }\n\n    var preparedItem = preparedItems[codename];\n\n    if (mappingStartedForCodenames.includes(codename)) {\n      return preparedItem;\n    }\n\n    mappingStartedForCodenames.push(codename); // by default errors are not thrown\n\n    var throwErrorForMissingLinkedItems = queryConfig.throwErrorForMissingLinkedItems === true ? true : false; // throw error if item is not in response and errors are not skipped\n\n    if (!preparedItem) {\n      if (throwErrorForMissingLinkedItems) {\n        throw Error(\"Linked item with codename '\" + codename + \"' could not be found in Delivery response.\\n                This linked item was requested by '\" + element.name + \"' element of '\" + element.type + \"'.\\n                Error can usually be solved by increasing 'Depth' parameter of your query.\\n                Alternatively, you may prevent this error by disabling 'throwErrorForMissingLinkedItems' in query configuration.\");\n      }\n\n      return undefined;\n    }\n\n    var mappedLinkedItem; // original resolving if item is still undefined\n\n    var mappedLinkedItemResult = this.mapElements({\n      item: preparedItem._raw,\n      preparedItems: preparedItems,\n      processingStartedForCodenames: mappingStartedForCodenames,\n      processedItems: processedItems,\n      queryConfig: queryConfig\n    });\n\n    if (mappedLinkedItemResult) {\n      mappedLinkedItem = mappedLinkedItemResult.item; // add to processed items\n\n      processedItems[codename] = mappedLinkedItem;\n    }\n\n    return mappedLinkedItem;\n  };\n\n  ElementMapper.prototype.mapRichTextLinks = function (linksJson) {\n    var links = [];\n\n    for (var _i = 0, _a = Object.keys(linksJson); _i < _a.length; _i++) {\n      var linkId = _a[_i];\n      var linkRaw = linksJson[linkId];\n      links.push(new models_1.Link({\n        codename: linkRaw.codename,\n        linkId: linkId,\n        urlSlug: linkRaw.url_slug,\n        type: linkRaw.type\n      }));\n    }\n\n    return links;\n  };\n\n  ElementMapper.prototype.mapRichTextImages = function (imagesJson) {\n    var images = [];\n\n    for (var _i = 0, _a = Object.keys(imagesJson); _i < _a.length; _i++) {\n      var imageId = _a[_i];\n      var imageRaw = imagesJson[imageId];\n      images.push(new models_1.RichTextImage({\n        description: imageRaw.description,\n        imageId: imageRaw.image_id,\n        url: imageRaw.url,\n        height: imageRaw.height,\n        width: imageRaw.width\n      }));\n    }\n\n    return images;\n  };\n\n  ElementMapper.prototype.resolveElementMap = function (item, originalElementCodename) {\n    var resolvedElementPropertyName = undefined; // resolve using property resolver\n\n    if (item._config && item._config.propertyResolver) {\n      resolvedElementPropertyName = item._config.propertyResolver(originalElementCodename);\n    } // if property hasn't been resolved, try getting name using decorator\n\n\n    if (resolvedElementPropertyName === originalElementCodename || !resolvedElementPropertyName) {\n      resolvedElementPropertyName = elements_1.ElementDecorators.getPropertyName(item, originalElementCodename);\n    }\n\n    if (!resolvedElementPropertyName) {\n      // use original element codename\n      resolvedElementPropertyName = originalElementCodename;\n    } // check for collissions\n\n\n    if (this.collidesWithAnotherProperty(resolvedElementPropertyName, item)) {\n      // try to resolve collission using dedicated resolver\n      var collisionResolver = this.getCollisionResolver();\n      resolvedElementPropertyName = collisionResolver(resolvedElementPropertyName); // verify again if the new element collides\n\n      if (this.collidesWithAnotherProperty(resolvedElementPropertyName, item)) {\n        console.warn(\"Element '\" + resolvedElementPropertyName + \"' collides with another element in same type. Element mapping is skipped. Source item: '\" + item.system.codename + \"'\");\n        return {\n          shouldMapElement: false,\n          resolvedName: ''\n        };\n      }\n    }\n\n    return {\n      resolvedName: resolvedElementPropertyName,\n      shouldMapElement: true\n    };\n  };\n\n  ElementMapper.prototype.getGlobalUrlSlugResolverForType = function (type) {\n    var item = resolvers_1.stronglyTypedResolver.createEmptyItemInstanceOfType(type, this.config.typeResolvers || []);\n\n    if (item && item._config && item._config.urlSlugResolver) {\n      return item._config.urlSlugResolver;\n    }\n\n    return undefined;\n  };\n\n  ElementMapper.prototype.getCollisionResolver = function () {\n    return this.config.collisionResolver ? this.config.collisionResolver : config_1.defaultCollissionResolver;\n  };\n\n  ElementMapper.prototype.collidesWithAnotherProperty = function (elementName, item) {\n    return item[elementName] ? true : false;\n  };\n\n  return ElementMapper;\n}();\n\nexports.ElementMapper = ElementMapper;","map":{"version":3,"sources":["../../lib/mappers/element.mapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ElementMapper = void 0;\r\nvar kontent_core_1 = require(\"@kentico/kontent-core\");\r\nvar config_1 = require(\"../config\");\r\nvar elements_1 = require(\"../elements\");\r\nvar models_1 = require(\"../models\");\r\nvar resolvers_1 = require(\"../resolvers\");\r\nvar ElementMapper = /** @class */ (function () {\r\n    function ElementMapper(config, richTextHtmlParser) {\r\n        this.config = config;\r\n        this.richTextHtmlParser = richTextHtmlParser;\r\n        this.defaultLinkedItemWrapperTag = 'p';\r\n        this.defaultLinkedItemWrapperClasses = ['kc-linked-item-wrapper'];\r\n    }\r\n    /**\r\n     * Maps all element in given content item and returns strongly typed content item based on the resolver specified\r\n     * in DeliveryClientConfig\r\n     */\r\n    ElementMapper.prototype.mapElements = function (data) {\r\n        var _this = this;\r\n        // return processed item if possible (to avoid infinite recursion)\r\n        var processedItem = data.processedItems[data.item.system.codename];\r\n        if (processedItem) {\r\n            // item was already resolved, return it\r\n            return {\r\n                item: processedItem,\r\n                processedItems: data.processedItems,\r\n                preparedItems: data.preparedItems,\r\n                processingStartedForCodenames: data.processingStartedForCodenames\r\n            };\r\n        }\r\n        var elementCodenames = Object.getOwnPropertyNames(data.item.elements);\r\n        var itemInstance = data.preparedItems[data.item.system.codename];\r\n        if (!itemInstance) {\r\n            // item is not present in response, no need to do any mapping\r\n            return undefined;\r\n        }\r\n        elementCodenames.forEach(function (elementCodename) {\r\n            var elementMap = _this.resolveElementMap(itemInstance, elementCodename);\r\n            var elementWrapper = {\r\n                contentItemSystem: data.item.system,\r\n                rawElement: data.item.elements[elementCodename],\r\n                propertyName: elementMap.resolvedName\r\n            };\r\n            if (elementMap.shouldMapElement) {\r\n                var mappedElement = _this.mapElement({\r\n                    elementWrapper: elementWrapper,\r\n                    item: itemInstance,\r\n                    preparedItems: data.preparedItems,\r\n                    processingStartedForCodenames: data.processingStartedForCodenames,\r\n                    processedItems: data.processedItems,\r\n                    queryConfig: data.queryConfig\r\n                });\r\n                // set mapped element to item instance\r\n                itemInstance[elementMap.resolvedName] = mappedElement;\r\n            }\r\n        });\r\n        return {\r\n            item: itemInstance,\r\n            processedItems: data.processedItems,\r\n            preparedItems: data.preparedItems,\r\n            processingStartedForCodenames: data.processingStartedForCodenames\r\n        };\r\n    };\r\n    ElementMapper.prototype.mapElement = function (data) {\r\n        var elementType = kontent_core_1.enumHelper.getEnumFromValue(elements_1.ElementType, data.elementWrapper.rawElement.type);\r\n        if (elementType) {\r\n            if (elementType === elements_1.ElementType.ModularContent) {\r\n                return this.mapLinkedItemsElement({\r\n                    elementWrapper: data.elementWrapper,\r\n                    preparedItems: data.preparedItems,\r\n                    processingStartedForCodenames: data.processingStartedForCodenames,\r\n                    processedItems: data.processedItems,\r\n                    queryConfig: data.queryConfig\r\n                });\r\n            }\r\n            if (elementType === elements_1.ElementType.Text) {\r\n                return this.mapTextElement(data.elementWrapper);\r\n            }\r\n            if (elementType === elements_1.ElementType.Asset) {\r\n                return this.mapAssetsElement(data.elementWrapper);\r\n            }\r\n            if (elementType === elements_1.ElementType.Number) {\r\n                return this.mapNumberElement(data.elementWrapper);\r\n            }\r\n            if (elementType === elements_1.ElementType.MultipleChoice) {\r\n                return this.mapMultipleChoiceElement(data.elementWrapper);\r\n            }\r\n            if (elementType === elements_1.ElementType.DateTime) {\r\n                return this.mapDateTimeElement(data.elementWrapper);\r\n            }\r\n            if (elementType === elements_1.ElementType.RichText) {\r\n                return this.mapRichTextElement(data.item, data.elementWrapper, data.queryConfig, data.processedItems, data.processingStartedForCodenames, data.preparedItems);\r\n            }\r\n            if (elementType === elements_1.ElementType.UrlSlug) {\r\n                return this.mapUrlSlugElement(data.elementWrapper, data.item, data.queryConfig);\r\n            }\r\n            if (elementType === elements_1.ElementType.Taxonomy) {\r\n                return this.mapTaxonomyElement(data.elementWrapper);\r\n            }\r\n            if (elementType === elements_1.ElementType.Custom) {\r\n                return this.mapCustomElement(data.elementWrapper);\r\n            }\r\n        }\r\n        console.warn(\"Could not map element '\" + data.elementWrapper.rawElement.name + \"' of type '\" + data.elementWrapper.rawElement.type + \"'. Returning unknown element instead.\");\r\n        return this.mapUnknowElement(data.elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapRichTextElement = function (item, elementWrapper, queryConfig, processedItems, processingStartedForCodenames, preparedItems) {\r\n        var _this = this;\r\n        // get all linked items nested in rich text\r\n        var richTextLinkedItems = [];\r\n        var rawElement = elementWrapper.rawElement;\r\n        if (rawElement.modular_content) {\r\n            if (Array.isArray(rawElement.modular_content)) {\r\n                rawElement.modular_content.forEach(function (codename) {\r\n                    // get linked item and check if it exists (it might not be included in response due to 'Depth' parameter)\r\n                    var preparedItem = preparedItems[codename];\r\n                    // first try to get existing item\r\n                    var existingLinkedItem = _this.getOrSaveLinkedItemForElement(codename, rawElement, queryConfig, processedItems, processingStartedForCodenames, preparedItems);\r\n                    if (existingLinkedItem) {\r\n                        // item was found, add it to linked items\r\n                        richTextLinkedItems.push(existingLinkedItem);\r\n                    }\r\n                    else {\r\n                        var throwErrorForMissingLinkedItems = false;\r\n                        // check if errors should be thrown for missing linked items\r\n                        if (queryConfig.throwErrorForMissingLinkedItems === false ||\r\n                            queryConfig.throwErrorForMissingLinkedItems === true) {\r\n                            // variable is a boolean\r\n                            throwErrorForMissingLinkedItems = queryConfig.throwErrorForMissingLinkedItems;\r\n                        }\r\n                        // throw error if raw item is not available and errors are not skipped\r\n                        if (!preparedItem) {\r\n                            var msg = \"Mapping RichTextElement element '\" + rawElement.name + \"' failed because referenced linked item with codename '\" + codename + \"' could not be found in Delivery response.\\n                            Increasing 'depth' parameter may solve this issue as it will include nested items. Alternatively you may disable 'throwErrorForMissingLinkedItems' in your query\";\r\n                            if (throwErrorForMissingLinkedItems) {\r\n                                throw Error(msg);\r\n                            }\r\n                        }\r\n                        // item was not found or not yet resolved\r\n                        if (preparedItem) {\r\n                            var mappedLinkedItemResult = _this.mapElements({\r\n                                item: preparedItem._raw,\r\n                                preparedItems: preparedItems,\r\n                                processingStartedForCodenames: processingStartedForCodenames,\r\n                                processedItems: processedItems,\r\n                                queryConfig: queryConfig\r\n                            });\r\n                            // add mapped linked item to result\r\n                            if (mappedLinkedItemResult) {\r\n                                richTextLinkedItems.push(mappedLinkedItemResult.item);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        // extract and map links & images\r\n        var links = this.mapRichTextLinks(rawElement.links);\r\n        var images = this.mapRichTextImages(rawElement.images);\r\n        return new elements_1.Elements.RichTextElement(elementWrapper, rawElement.modular_content, {\r\n            links: links,\r\n            resolveRichTextFunc: function () {\r\n                return resolvers_1.richTextResolver.resolveData(item.system.codename, rawElement.value, elementWrapper.propertyName, {\r\n                    enableAdvancedLogging: _this.config.isDeveloperMode ? _this.config.isDeveloperMode : false,\r\n                    getGlobalUrlSlugResolver: function (type) { return _this.getGlobalUrlSlugResolverForType(type); },\r\n                    images: images,\r\n                    richTextHtmlParser: _this.richTextHtmlParser,\r\n                    getLinkedItem: function (codename) {\r\n                        return _this.getOrSaveLinkedItemForElement(codename, rawElement, queryConfig, processedItems, processingStartedForCodenames, preparedItems);\r\n                    },\r\n                    links: links,\r\n                    queryConfig: queryConfig,\r\n                    linkedItemWrapperTag: _this.config.linkedItemResolver && _this.config.linkedItemResolver.linkedItemWrapperTag\r\n                        ? _this.config.linkedItemResolver.linkedItemWrapperTag\r\n                        : _this.defaultLinkedItemWrapperTag,\r\n                    linkedItemWrapperClasses: _this.config.linkedItemResolver && _this.config.linkedItemResolver.linkedItemWrapperClasses\r\n                        ? _this.config.linkedItemResolver.linkedItemWrapperClasses\r\n                        : _this.defaultLinkedItemWrapperClasses\r\n                });\r\n            },\r\n            images: images\r\n        });\r\n    };\r\n    ElementMapper.prototype.mapDateTimeElement = function (elementWrapper) {\r\n        return new elements_1.Elements.DateTimeElement(elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapMultipleChoiceElement = function (elementWrapper) {\r\n        return new elements_1.Elements.MultipleChoiceElement(elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapNumberElement = function (elementWrapper) {\r\n        return new elements_1.Elements.NumberElement(elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapTextElement = function (elementWrapper) {\r\n        return new elements_1.Elements.TextElement(elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapAssetsElement = function (elementWrapper) {\r\n        return new elements_1.Elements.AssetsElement(elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapTaxonomyElement = function (elementWrapper) {\r\n        return new elements_1.Elements.TaxonomyElement(elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapUnknowElement = function (elementWrapper) {\r\n        return new elements_1.Elements.UnknownElement(elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapCustomElement = function (elementWrapper) {\r\n        // try to find element resolver\r\n        if (this.config.elementResolver) {\r\n            var customElementClass = this.config.elementResolver(elementWrapper);\r\n            if (customElementClass) {\r\n                return customElementClass;\r\n            }\r\n        }\r\n        return new elements_1.Elements.DefaultCustomElement(elementWrapper);\r\n    };\r\n    ElementMapper.prototype.mapUrlSlugElement = function (elementWrapper, item, queryConfig) {\r\n        var _this = this;\r\n        var resolver = this.getUrlSlugResolverForElement(item, elementWrapper, queryConfig);\r\n        return new elements_1.Elements.UrlSlugElement(elementWrapper, {\r\n            resolveLinkFunc: function () {\r\n                return resolvers_1.urlSlugResolver.resolveUrl({\r\n                    elementName: elementWrapper.propertyName,\r\n                    elementValue: elementWrapper.rawElement.value,\r\n                    item: item,\r\n                    enableAdvancedLogging: _this.config.isDeveloperMode ? _this.config.isDeveloperMode : false,\r\n                    resolver: resolver\r\n                }).url || '';\r\n            }\r\n        });\r\n    };\r\n    ElementMapper.prototype.mapLinkedItemsElement = function (data) {\r\n        var _this = this;\r\n        // prepare linked items\r\n        var linkedItems = [];\r\n        // value = array of item codenames\r\n        var linkedItemCodenames = data.elementWrapper.rawElement.value;\r\n        linkedItemCodenames.forEach(function (codename) {\r\n            var linkedItem = _this.getOrSaveLinkedItemForElement(codename, data.elementWrapper.rawElement, data.queryConfig, data.processedItems, data.processingStartedForCodenames, data.preparedItems);\r\n            if (linkedItem) {\r\n                // add item to result\r\n                linkedItems.push(linkedItem);\r\n            }\r\n            else {\r\n                // item was not found\r\n                if (_this.config.isDeveloperMode) {\r\n                    // tslint:disable-next-line:max-line-length\r\n                    console.warn(\"Linked item with codename '\" + codename + \"' in linked items element '\" + data.elementWrapper.rawElement.name + \"' of '\" + data.elementWrapper.rawElement.type + \"' type could not be found. If you require this item, consider increasing 'depth' of your query. This warning can be turned off by disabling 'enableAdvancedLogging' option.\");\r\n                }\r\n            }\r\n        });\r\n        return new elements_1.Elements.LinkedItemsElement(data.elementWrapper, linkedItems);\r\n    };\r\n    ElementMapper.prototype.getUrlSlugResolverForElement = function (item, elementWrapper, queryConfig) {\r\n        // query `urlSlugResolver` has priority over global resolver\r\n        if (queryConfig.urlSlugResolver) {\r\n            return queryConfig.urlSlugResolver;\r\n        }\r\n        if (item._config && item._config.urlSlugResolver) {\r\n            return item._config.urlSlugResolver;\r\n        }\r\n        // resolve default link value\r\n        return function () { return elementWrapper.rawElement.value; };\r\n    };\r\n    ElementMapper.prototype.getOrSaveLinkedItemForElement = function (codename, element, queryConfig, processedItems, mappingStartedForCodenames, preparedItems) {\r\n        // first check if item was already resolved and return it if it was\r\n        var processedItem = processedItems[codename];\r\n        if (processedItem) {\r\n            // item was already resolved\r\n            return processedItem;\r\n        }\r\n        var preparedItem = preparedItems[codename];\r\n        if (mappingStartedForCodenames.includes(codename)) {\r\n            return preparedItem;\r\n        }\r\n        mappingStartedForCodenames.push(codename);\r\n        // by default errors are not thrown\r\n        var throwErrorForMissingLinkedItems = queryConfig.throwErrorForMissingLinkedItems === true ? true : false;\r\n        // throw error if item is not in response and errors are not skipped\r\n        if (!preparedItem) {\r\n            if (throwErrorForMissingLinkedItems) {\r\n                throw Error(\"Linked item with codename '\" + codename + \"' could not be found in Delivery response.\\n                This linked item was requested by '\" + element.name + \"' element of '\" + element.type + \"'.\\n                Error can usually be solved by increasing 'Depth' parameter of your query.\\n                Alternatively, you may prevent this error by disabling 'throwErrorForMissingLinkedItems' in query configuration.\");\r\n            }\r\n            return undefined;\r\n        }\r\n        var mappedLinkedItem;\r\n        // original resolving if item is still undefined\r\n        var mappedLinkedItemResult = this.mapElements({\r\n            item: preparedItem._raw,\r\n            preparedItems: preparedItems,\r\n            processingStartedForCodenames: mappingStartedForCodenames,\r\n            processedItems: processedItems,\r\n            queryConfig: queryConfig\r\n        });\r\n        if (mappedLinkedItemResult) {\r\n            mappedLinkedItem = mappedLinkedItemResult.item;\r\n            // add to processed items\r\n            processedItems[codename] = mappedLinkedItem;\r\n        }\r\n        return mappedLinkedItem;\r\n    };\r\n    ElementMapper.prototype.mapRichTextLinks = function (linksJson) {\r\n        var links = [];\r\n        for (var _i = 0, _a = Object.keys(linksJson); _i < _a.length; _i++) {\r\n            var linkId = _a[_i];\r\n            var linkRaw = linksJson[linkId];\r\n            links.push(new models_1.Link({\r\n                codename: linkRaw.codename,\r\n                linkId: linkId,\r\n                urlSlug: linkRaw.url_slug,\r\n                type: linkRaw.type\r\n            }));\r\n        }\r\n        return links;\r\n    };\r\n    ElementMapper.prototype.mapRichTextImages = function (imagesJson) {\r\n        var images = [];\r\n        for (var _i = 0, _a = Object.keys(imagesJson); _i < _a.length; _i++) {\r\n            var imageId = _a[_i];\r\n            var imageRaw = imagesJson[imageId];\r\n            images.push(new models_1.RichTextImage({\r\n                description: imageRaw.description,\r\n                imageId: imageRaw.image_id,\r\n                url: imageRaw.url,\r\n                height: imageRaw.height,\r\n                width: imageRaw.width\r\n            }));\r\n        }\r\n        return images;\r\n    };\r\n    ElementMapper.prototype.resolveElementMap = function (item, originalElementCodename) {\r\n        var resolvedElementPropertyName = undefined;\r\n        // resolve using property resolver\r\n        if (item._config && item._config.propertyResolver) {\r\n            resolvedElementPropertyName = item._config.propertyResolver(originalElementCodename);\r\n        }\r\n        // if property hasn't been resolved, try getting name using decorator\r\n        if (resolvedElementPropertyName === originalElementCodename || !resolvedElementPropertyName) {\r\n            resolvedElementPropertyName = elements_1.ElementDecorators.getPropertyName(item, originalElementCodename);\r\n        }\r\n        if (!resolvedElementPropertyName) {\r\n            // use original element codename\r\n            resolvedElementPropertyName = originalElementCodename;\r\n        }\r\n        // check for collissions\r\n        if (this.collidesWithAnotherProperty(resolvedElementPropertyName, item)) {\r\n            // try to resolve collission using dedicated resolver\r\n            var collisionResolver = this.getCollisionResolver();\r\n            resolvedElementPropertyName = collisionResolver(resolvedElementPropertyName);\r\n            // verify again if the new element collides\r\n            if (this.collidesWithAnotherProperty(resolvedElementPropertyName, item)) {\r\n                console.warn(\"Element '\" + resolvedElementPropertyName + \"' collides with another element in same type. Element mapping is skipped. Source item: '\" + item.system.codename + \"'\");\r\n                return {\r\n                    shouldMapElement: false,\r\n                    resolvedName: ''\r\n                };\r\n            }\r\n        }\r\n        return {\r\n            resolvedName: resolvedElementPropertyName,\r\n            shouldMapElement: true\r\n        };\r\n    };\r\n    ElementMapper.prototype.getGlobalUrlSlugResolverForType = function (type) {\r\n        var item = resolvers_1.stronglyTypedResolver.createEmptyItemInstanceOfType(type, this.config.typeResolvers || []);\r\n        if (item && item._config && item._config.urlSlugResolver) {\r\n            return item._config.urlSlugResolver;\r\n        }\r\n        return undefined;\r\n    };\r\n    ElementMapper.prototype.getCollisionResolver = function () {\r\n        return this.config.collisionResolver ? this.config.collisionResolver : config_1.defaultCollissionResolver;\r\n    };\r\n    ElementMapper.prototype.collidesWithAnotherProperty = function (elementName, item) {\r\n        return item[elementName] ? true : false;\r\n    };\r\n    return ElementMapper;\r\n}());\r\nexports.ElementMapper = ElementMapper;\r\n//# sourceMappingURL=element.mapper.js.map"]},"metadata":{},"sourceType":"script"}