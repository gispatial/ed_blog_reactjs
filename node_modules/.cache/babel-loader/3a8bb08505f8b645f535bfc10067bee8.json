{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.observableRetryStrategy = exports.ObservableRetryStrategy = void 0;\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar retry_service_1 = require(\"./retry-service\");\n\nvar ObservableRetryStrategy =\n/** @class */\nfunction () {\n  function ObservableRetryStrategy() {\n    this.strategy = function (options, internal) {\n      return function (errorObs) {\n        return errorObs.pipe(operators_1.flatMap(function (error, i) {\n          var canRetryError = options.canRetryError(error);\n\n          if (!canRetryError) {\n            // request cannot be retried\n            return rxjs_1.throwError(error);\n          }\n\n          var retryAttempt = i + 1;\n          var maximumRetryAttemptsMet = retryAttempt > options.maxAttempts;\n\n          if (maximumRetryAttemptsMet) {\n            // request cannot be retried anymore due to maximum attempts\n            return rxjs_1.throwError(error);\n          }\n\n          var retryInTimeResult = retry_service_1.retryService.canRetryInTime(internal.startTime, options.maxCumulativeWaitTimeMs);\n\n          if (!retryInTimeResult.canRetry) {\n            // request should not be retried anymore as allowed time expired\n            return rxjs_1.throwError(error);\n          } // get wait time\n\n\n          var retryAfter = retry_service_1.retryService.tryGetRetryAfterInMsFromError(error);\n          var waitTime = retry_service_1.retryService.getNextWaitTimeMs(options.addJitter, options.deltaBackoffMs, retryAttempt, retryAfter); // debug log attempt\n\n          retry_service_1.retryService.debugLogAttempt(retryAttempt, waitTime);\n          return rxjs_1.timer(waitTime);\n        }));\n      };\n    };\n  }\n\n  return ObservableRetryStrategy;\n}();\n\nexports.ObservableRetryStrategy = ObservableRetryStrategy;\nexports.observableRetryStrategy = new ObservableRetryStrategy();","map":{"version":3,"sources":["../../lib/http/observable-retry-strategy.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAGA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAEA,IAAA,uBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,uBAAA,GAAA;AACI,SAAA,QAAA,GAAW,UACP,OADO,EAEP,QAFO,EAKN;AACA,aAAA,UAAC,QAAD,EAA0B;AAC3B,eAAO,QAAQ,CAAC,IAAT,CACH,WAAA,CAAA,OAAA,CAAQ,UAAC,KAAD,EAAa,CAAb,EAAsB;AAC1B,cAAM,aAAa,GAAY,OAAO,CAAC,aAAR,CAAsB,KAAtB,CAA/B;;AAEA,cAAI,CAAC,aAAL,EAAoB;AAChB;AACA,mBAAO,MAAA,CAAA,UAAA,CAAW,KAAX,CAAP;AACH;;AAGD,cAAM,YAAY,GAAG,CAAC,GAAG,CAAzB;AAEA,cAAM,uBAAuB,GAAY,YAAY,GAAG,OAAO,CAAC,WAAhE;;AAEA,cAAI,uBAAJ,EAA6B;AACzB;AACA,mBAAO,MAAA,CAAA,UAAA,CAAW,KAAX,CAAP;AACH;;AAED,cAAM,iBAAiB,GAAG,eAAA,CAAA,YAAA,CAAa,cAAb,CACtB,QAAQ,CAAC,SADa,EAEtB,OAAO,CAAC,uBAFc,CAA1B;;AAKA,cAAI,CAAC,iBAAiB,CAAC,QAAvB,EAAiC;AAC7B;AACA,mBAAO,MAAA,CAAA,UAAA,CAAW,KAAX,CAAP;AACH,WA1ByB,CA4B1B;;;AACA,cAAM,UAAU,GAAuB,eAAA,CAAA,YAAA,CAAa,6BAAb,CAA2C,KAA3C,CAAvC;AACA,cAAM,QAAQ,GAAG,eAAA,CAAA,YAAA,CAAa,iBAAb,CACb,OAAO,CAAC,SADK,EAEb,OAAO,CAAC,cAFK,EAGb,YAHa,EAIb,UAJa,CAAjB,CA9B0B,CAqC1B;;AACA,UAAA,eAAA,CAAA,YAAA,CAAa,eAAb,CAA6B,YAA7B,EAA2C,QAA3C;AAEA,iBAAO,MAAA,CAAA,KAAA,CAAM,QAAN,CAAP;AACH,SAzCD,CADG,CAAP;AADC,OAAA;AA6CJ,KAnDD;AAoDH;;AAAD,SAAA,uBAAA;AAAC,CArDD,EAAA;;AAAa,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAuDA,OAAA,CAAA,uBAAA,GAA0B,IAAI,uBAAJ,EAA1B","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.observableRetryStrategy = exports.ObservableRetryStrategy = void 0;\r\nvar rxjs_1 = require(\"rxjs\");\r\nvar operators_1 = require(\"rxjs/operators\");\r\nvar retry_service_1 = require(\"./retry-service\");\r\nvar ObservableRetryStrategy = /** @class */ (function () {\r\n    function ObservableRetryStrategy() {\r\n        this.strategy = function (options, internal) { return function (errorObs) {\r\n            return errorObs.pipe(operators_1.flatMap(function (error, i) {\r\n                var canRetryError = options.canRetryError(error);\r\n                if (!canRetryError) {\r\n                    // request cannot be retried\r\n                    return rxjs_1.throwError(error);\r\n                }\r\n                var retryAttempt = i + 1;\r\n                var maximumRetryAttemptsMet = retryAttempt > options.maxAttempts;\r\n                if (maximumRetryAttemptsMet) {\r\n                    // request cannot be retried anymore due to maximum attempts\r\n                    return rxjs_1.throwError(error);\r\n                }\r\n                var retryInTimeResult = retry_service_1.retryService.canRetryInTime(internal.startTime, options.maxCumulativeWaitTimeMs);\r\n                if (!retryInTimeResult.canRetry) {\r\n                    // request should not be retried anymore as allowed time expired\r\n                    return rxjs_1.throwError(error);\r\n                }\r\n                // get wait time\r\n                var retryAfter = retry_service_1.retryService.tryGetRetryAfterInMsFromError(error);\r\n                var waitTime = retry_service_1.retryService.getNextWaitTimeMs(options.addJitter, options.deltaBackoffMs, retryAttempt, retryAfter);\r\n                // debug log attempt\r\n                retry_service_1.retryService.debugLogAttempt(retryAttempt, waitTime);\r\n                return rxjs_1.timer(waitTime);\r\n            }));\r\n        }; };\r\n    }\r\n    return ObservableRetryStrategy;\r\n}());\r\nexports.ObservableRetryStrategy = ObservableRetryStrategy;\r\nexports.observableRetryStrategy = new ObservableRetryStrategy();\r\n//# sourceMappingURL=observable-retry-strategy.js.map"]},"metadata":{},"sourceType":"script"}